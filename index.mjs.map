{"version":3,"file":"index.mjs","sources":["../lib/validate.js","../lib/main.js","../lib/sync.js","../lib/index.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport isObject from '@stdlib/assert-is-plain-object';\nimport hasOwnProp from '@stdlib/assert-has-own-property';\nimport { isPrimitive as isString } from '@stdlib/assert-is-string';\nimport { factory as contains } from '@stdlib/array-base-assert-contains';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// VARIABLES //\n\nvar isMode = contains( [ 'first', 'some', 'all', 'each' ] );\n\n\n// MAIN //\n\n/**\n* Validates function options.\n*\n* @private\n* @param {Object} opts - destination object\n* @param {Options} options - function options\n* @param {string} [options.dir] - base directory\n* @param {string} [options.mode] - operation mode\n* @returns {(Error|null)} error object or null\n*\n* @example\n* var opts = {};\n* var options = {\n*     'dir': '/foo/bar/baz',\n*     'mode': 'some'\n* };\n*\n* var err = validate( opts, options );\n* if ( err ) {\n*    throw err;\n* }\n*/\nfunction validate( opts, options ) {\n\tif ( !isObject( options ) ) {\n\t\treturn new TypeError( format( 'null2V', options ) );\n\t}\n\tif ( hasOwnProp( options, 'dir' ) ) {\n\t\topts.dir = options.dir;\n\t\tif ( !isString( opts.dir ) ) {\n\t\t\treturn new TypeError( format( 'null2W', 'dir', opts.dir ) );\n\t\t}\n\t}\n\tif ( hasOwnProp( options, 'mode' ) ) {\n\t\topts.mode = options.mode;\n\t\tif ( !isMode( opts.mode ) ) {\n\t\t\treturn new TypeError( format( 'invalid option. `%s` option must be a valid mode. Option: `%s`.', 'mode', opts.mode ) );\n\t\t}\n\t}\n\treturn null;\n}\n\n\n// EXPORTS //\n\nexport default validate;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar resolve = require( 'path' ).resolve;\nimport { primitives as isStringArray } from '@stdlib/assert-is-string-array';\nimport isArrayLikeObject from '@stdlib/assert-is-array-like-object';\nimport isFunction from '@stdlib/assert-is-function';\nimport cwd from '@stdlib/process-cwd';\nimport exists from '@stdlib/fs-exists';\nimport nulls from '@stdlib/array-base-nulls';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport validate from './validate.js';\n\n\n// VARIABLES //\n\nvar MODES = {\n\t'first': first,\n\t'some': some,\n\t'all': all,\n\t'each': each\n};\n\n\n// FUNCTIONS //\n\n/**\n* Asynchronously resolves the first path match from a set of paths by walking parent directories.\n*\n* @private\n* @param {Array<string>} paths - paths to resolve\n* @param {string} dir - base directory\n* @param {Callback} done - callback to invoke after resolving paths\n* @returns {void}\n*/\nfunction first( paths, dir, done ) {\n\tvar child;\n\tvar spath;\n\tvar idx;\n\tvar out;\n\n\tout = [];\n\n\t// Start at a base directory and continue moving up through each parent directory...\n\tspath = resolve( dir, paths[ 0 ] );\n\n\tidx = 1; // index of next path\n\texists( spath, onExists );\n\n\t/**\n\t* Callback invoked after checking for path existence.\n\t*\n\t* @private\n\t* @param {(Error|null)} error - error object\n\t* @param {boolean} bool - boolean indicating if a path exists\n\t* @returns {void}\n\t*/\n\tfunction onExists( error, bool ) { // eslint-disable-line node/handle-callback-err\n\t\tif ( bool ) {\n\t\t\tout.push( spath );\n\t\t\treturn done( null, out );\n\t\t}\n\t\t// If we have traversed all paths at the current directory level, resolve parent directory...\n\t\tif ( idx === paths.length ) {\n\t\t\t// Resolve a parent directory:\n\t\t\tchild = dir;\n\t\t\tdir = resolve( dir, '..' );\n\n\t\t\t// If we have already reached root, we cannot resolve any higher directories...\n\t\t\tif ( child === dir ) {\n\t\t\t\treturn done( null, out );\n\t\t\t}\n\t\t\tidx = 0;\n\t\t}\n\t\tspath = resolve( dir, paths[ idx ] );\n\t\tidx += 1;\n\t\texists( spath, onExists );\n\t}\n}\n\n/**\n* Asynchronously resolves one or more paths from a set of paths at a directory level by walking parent directories.\n*\n* @private\n* @param {Array<string>} paths - paths to resolve\n* @param {string} dir - base directory\n* @param {Callback} done - callback to invoke after resolving paths\n* @returns {void}\n*/\nfunction some( paths, dir, done ) {\n\tvar child;\n\tvar spath;\n\tvar FLG;\n\tvar out;\n\n\tFLG = 0; // initialize flag to track if we are done traversing a directory level\n\tout = [];\n\n\t// Start at a base directory and continue moving up through each parent directory...\n\treturn next( dir );\n\n\t/**\n\t* Resolves paths within a directory.\n\t*\n\t* @private\n\t* @param {string} dir - directory to search\n\t*/\n\tfunction next( dir ) {\n\t\tvar i;\n\t\tfor ( i = 0; i < paths.length; i++ ) {\n\t\t\tspath = resolve( dir, paths[ i ] );\n\t\t\texists( spath, getCallback( spath ) );\n\t\t}\n\t}\n\n\t/**\n\t* Returns a callback to be invoked upon checking for path existence.\n\t*\n\t* @private\n\t* @param {string} spath - resolved path\n\t* @returns {Callback} callback\n\t*/\n\tfunction getCallback( spath ) {\n\t\treturn onExists;\n\n\t\t/**\n\t\t* Callback invoked after checking for path existence.\n\t\t*\n\t\t* @private\n\t\t* @param {(Error|null)} error - error object\n\t\t* @param {boolean} bool - boolean indicating if a path exists\n\t\t* @returns {void}\n\t\t*/\n\t\tfunction onExists( error, bool ) { // eslint-disable-line node/handle-callback-err\n\t\t\tif ( bool ) {\n\t\t\t\tout.push( spath );\n\t\t\t}\n\t\t\tFLG += 1;\n\t\t\tif ( FLG === paths.length ) {\n\t\t\t\t// Check if we have resolved any paths...\n\t\t\t\tif ( out.length > 0 ) {\n\t\t\t\t\treturn done( null, out );\n\t\t\t\t}\n\t\t\t\t// Resolve a parent directory:\n\t\t\t\tchild = dir;\n\t\t\t\tdir = resolve( dir, '..' );\n\n\t\t\t\t// Reset flag:\n\t\t\t\tFLG = 0;\n\n\t\t\t\t// If we have already reached root, we cannot resolve any higher directories...\n\t\t\t\tif ( child === dir ) {\n\t\t\t\t\treturn done( null, out );\n\t\t\t\t}\n\t\t\t\t// Resolve paths at next directory level:\n\t\t\t\treturn next( dir );\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n* Asynchronously resolves all paths from a set of paths at a directory level by walking parent directories.\n*\n* @private\n* @param {Array<string>} paths - paths to resolve\n* @param {string} dir - base directory\n* @param {Callback} done - callback to invoke after resolving paths\n* @returns {void}\n*/\nfunction all( paths, dir, done ) {\n\tvar count;\n\tvar child;\n\tvar spath;\n\tvar FLG;\n\tvar out;\n\n\tcount = 0; // initialize counter to track if we are done resolving all paths\n\tFLG = 0; // initialize flag to track if we are done traversing a directory level\n\tout = nulls( paths.length );\n\n\t// Start at a base directory and continue moving up through each parent directory...\n\treturn next( dir );\n\n\t/**\n\t* Resolves paths within a directory.\n\t*\n\t* @private\n\t* @param {string} dir - directory to search\n\t*/\n\tfunction next( dir ) {\n\t\tvar i;\n\t\tfor ( i = 0; i < paths.length; i++ ) {\n\t\t\tspath = resolve( dir, paths[ i ] );\n\t\t\texists( spath, getCallback( i, spath ) );\n\t\t}\n\t}\n\n\t/**\n\t* Returns a callback to be invoked upon checking for path existence.\n\t*\n\t* @private\n\t* @param {NonNegativeInteger} idx - index\n\t* @param {string} spath - resolved path\n\t* @returns {Callback} callback\n\t*/\n\tfunction getCallback( idx, spath ) {\n\t\treturn onExists;\n\n\t\t/**\n\t\t* Callback invoked after checking for path existence.\n\t\t*\n\t\t* @private\n\t\t* @param {(Error|null)} error - error object\n\t\t* @param {boolean} bool - boolean indicating if a path exists\n\t\t* @returns {void}\n\t\t*/\n\t\tfunction onExists( error, bool ) { // eslint-disable-line node/handle-callback-err\n\t\t\tif ( bool ) {\n\t\t\t\tout[ idx ] = spath;\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t\tFLG += 1;\n\t\t\tif ( FLG === paths.length ) {\n\t\t\t\t// Check if we have resolved any path...\n\t\t\t\tif ( count === paths.length ) {\n\t\t\t\t\treturn done( null, out );\n\t\t\t\t}\n\t\t\t\t// Resolve a parent directory:\n\t\t\t\tchild = dir;\n\t\t\t\tdir = resolve( dir, '..' );\n\n\t\t\t\t// Reset flag and buffers:\n\t\t\t\tFLG = 0;\n\t\t\t\tout = [];\n\t\t\t\tcount = 0;\n\n\t\t\t\t// If we have already reached root, we cannot resolve any higher directories...\n\t\t\t\tif ( child === dir ) {\n\t\t\t\t\treturn done( null, out );\n\t\t\t\t}\n\t\t\t\t// Resolve paths at next directory level:\n\t\t\t\treturn next( dir );\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n* Asynchronously resolves each path from a set of paths by walking parent directories.\n*\n* @private\n* @param {Array<string>} paths - paths to resolve\n* @param {string} dir - base directory\n* @param {Callback} done - callback to invoke after resolving paths\n* @returns {void}\n*/\nfunction each( paths, dir, done ) {\n\tvar count;\n\tvar child;\n\tvar spath;\n\tvar out;\n\tvar i;\n\n\tcount = 0; // initialize counter to track if we are done resolving all paths\n\tout = nulls( paths.length );\n\n\t// Start at a base directory and continue moving up through each parent directory...\n\tfor ( i = 0; i < paths.length; i++ ) {\n\t\tspath = resolve( dir, paths[ i ] );\n\t\texists( spath, getCallback( i, spath, dir ) );\n\t}\n\n\t/**\n\t* Determines whether all paths have been resolved.\n\t*\n\t* @private\n\t* @returns {void}\n\t*/\n\tfunction next() {\n\t\tcount += 1;\n\t\tif ( count === paths.length ) {\n\t\t\treturn done( null, out );\n\t\t}\n\t}\n\n\t/**\n\t* Returns a callback to be invoked upon checking for path existence.\n\t*\n\t* @private\n\t* @param {NonNegativeInteger} idx - index\n\t* @param {string} spath - resolved path\n\t* @param {string} dir - base directory\n\t* @returns {Callback} callback\n\t*/\n\tfunction getCallback( idx, spath, dir ) {\n\t\treturn onExists;\n\n\t\t/**\n\t\t* Callback invoked after checking for path existence.\n\t\t*\n\t\t* @private\n\t\t* @param {(Error|null)} error - error object\n\t\t* @param {boolean} bool - boolean indicating if a path exists\n\t\t* @returns {void}\n\t\t*/\n\t\tfunction onExists( error, bool ) { // eslint-disable-line node/handle-callback-err\n\t\t\tif ( bool ) {\n\t\t\t\tout[ idx ] = spath;\n\t\t\t\treturn next();\n\t\t\t}\n\t\t\t// Resolve a parent directory:\n\t\t\tchild = dir;\n\t\t\tdir = resolve( dir, '..' );\n\n\t\t\t// If we have already reached root, we cannot resolve any higher directories...\n\t\t\tif ( child === dir ) {\n\t\t\t\tout[ idx ] = null;\n\t\t\t\treturn next();\n\t\t\t}\n\t\t\t// Resolve path at next directory level:\n\t\t\tspath = resolve( dir, paths[ idx ] );\n\t\t\texists( spath, getCallback( idx, spath, dir ) );\n\t\t}\n\t}\n}\n\n\n// MAIN //\n\n/**\n* Asynchronously resolves paths from a set of paths by walking parent directories.\n*\n* @param {Array<string>} paths - paths to resolve\n* @param {Options} [options] - function options\n* @param {string} [options.dir] - base directory\n* @param {string} [options.mode] - mode of operation\n* @param {Callback} clbk - callback to invoke after resolving paths\n* @throws {TypeError} first argument must be an array of strings\n* @throws {TypeError} callback argument must be a function\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @returns {void}\n*\n* @example\n* resolveParentPaths( [ 'package.json', 'package-lock.json' ], onPaths );\n*\n* function onPaths( error, paths ) {\n*     if ( error ) {\n*         throw error;\n*     }\n*     console.log( paths );\n* }\n*/\nfunction resolveParentPaths( paths, options, clbk ) {\n\tvar opts;\n\tvar done;\n\tvar mode;\n\tvar dir;\n\tvar fcn;\n\tvar err;\n\n\tif ( !isStringArray( paths ) ) {\n\t\tif ( isArrayLikeObject( paths ) && paths.length === 0 ) {\n\t\t\treturn [];\n\t\t}\n\t\tthrow new TypeError( format( 'null3s', paths ) );\n\t}\n\topts = {};\n\tif ( arguments.length > 2 ) {\n\t\tdone = clbk;\n\t\terr = validate( opts, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t} else {\n\t\tdone = options;\n\t}\n\tif ( !isFunction( done ) ) {\n\t\tthrow new TypeError( format( 'null2b', done ) );\n\t}\n\tif ( opts.dir ) {\n\t\tdir = resolve( cwd(), opts.dir );\n\t} else {\n\t\tdir = cwd();\n\t}\n\tmode = opts.mode || 'all';\n\n\tfcn = MODES[ mode ];\n\tfcn( paths, dir, done );\n}\n\n\n// EXPORTS //\n\nexport default resolveParentPaths;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nvar resolve = require( 'path' ).resolve;\nimport { primitives as isStringArray } from '@stdlib/assert-is-string-array';\nimport isArrayLikeObject from '@stdlib/assert-is-array-like-object';\nimport cwd from '@stdlib/process-cwd';\nimport { sync as exists } from '@stdlib/fs-exists';\nimport nulls from '@stdlib/array-base-nulls';\nimport format from '@stdlib/error-tools-fmtprodmsg';\nimport validate from './validate.js';\n\n\n// VARIABLES //\n\nvar MODES = {\n\t'first': first,\n\t'some': some,\n\t'all': all,\n\t'each': each\n};\n\n\n// FUNCTIONS //\n\n/**\n* Synchronously resolves the first path match from a set of paths by walking parent directories.\n*\n* @private\n* @param {Array<string>} paths - paths to resolve\n* @param {string} dir - base directory\n* @returns {Array<string>} resolved paths\n*/\nfunction first( paths, dir ) {\n\tvar child;\n\tvar spath;\n\tvar out;\n\tvar i;\n\n\t// Start at a base directory and continue moving up through each parent directory...\n\tout = [];\n\twhile ( child !== dir ) {\n\t\tfor ( i = 0; i < paths.length; i++ ) {\n\t\t\tspath = resolve( dir, paths[ i ] );\n\t\t\tif ( exists( spath ) ) {\n\t\t\t\tout.push( spath );\n\t\t\t\treturn out;\n\t\t\t}\n\t\t}\n\t\tchild = dir;\n\t\tdir = resolve( dir, '..' );\n\t}\n\treturn out;\n}\n\n/**\n* Synchronously resolves one or more paths from a set of paths at a directory level by walking parent directories.\n*\n* @private\n* @param {Array<string>} paths - paths to resolve\n* @param {string} dir - base directory\n* @returns {Array<string>} resolved paths\n*/\nfunction some( paths, dir ) {\n\tvar child;\n\tvar spath;\n\tvar out;\n\tvar i;\n\n\t// Start at a base directory and continue moving up through each parent directory...\n\tout = [];\n\twhile ( child !== dir ) {\n\t\tfor ( i = 0; i < paths.length; i++ ) {\n\t\t\tspath = resolve( dir, paths[ i ] );\n\t\t\tif ( exists( spath ) ) {\n\t\t\t\tout.push( spath );\n\t\t\t}\n\t\t}\n\t\tif ( out.length > 0 ) {\n\t\t\treturn out;\n\t\t}\n\t\tchild = dir;\n\t\tdir = resolve( dir, '..' );\n\t}\n\treturn out;\n}\n\n/**\n* Synchronously resolves all paths from a set of paths at a directory level by walking parent directories.\n*\n* @private\n* @param {Array<string>} paths - paths to resolve\n* @param {string} dir - base directory\n* @returns {Array<string>} resolved paths\n*/\nfunction all( paths, dir ) {\n\tvar child;\n\tvar spath;\n\tvar out;\n\tvar i;\n\n\t// Start at a base directory and continue moving up through each parent directory...\n\tout = [];\n\twhile ( child !== dir ) {\n\t\tfor ( i = 0; i < paths.length; i++ ) {\n\t\t\tspath = resolve( dir, paths[ i ] );\n\t\t\tif ( exists( spath ) ) {\n\t\t\t\tout.push( spath );\n\t\t\t}\n\t\t}\n\t\tif ( out.length === paths.length ) {\n\t\t\treturn out;\n\t\t}\n\t\tout = [];\n\t\tchild = dir;\n\t\tdir = resolve( dir, '..' );\n\t}\n\treturn out;\n}\n\n/**\n* Synchronously resolves each path from a set of paths by walking parent directories.\n*\n* @private\n* @param {Array<string>} paths - paths to resolve\n* @param {string} dir - base directory\n* @returns {Array<string|null>} resolved paths\n*/\nfunction each( paths, dir ) {\n\tvar count;\n\tvar child;\n\tvar spath;\n\tvar out;\n\tvar i;\n\n\tcount = 0;\n\tout = nulls( paths.length );\n\n\t// Start at a base directory and continue moving up through each parent directory...\n\twhile ( child !== dir ) {\n\t\tfor ( i = 0; i < paths.length; i++ ) {\n\t\t\tif ( out[ i ] !== null ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tspath = resolve( dir, paths[ i ] );\n\t\t\tif ( exists( spath ) ) {\n\t\t\t\tout[ i ] = spath;\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\t\tif ( count === paths.length ) {\n\t\t\tbreak;\n\t\t}\n\t\tchild = dir;\n\t\tdir = resolve( dir, '..' );\n\t}\n\treturn out;\n}\n\n\n// MAIN //\n\n/**\n* Synchronously resolves paths from a set of paths by walking parent directories.\n*\n* @param {Array<string>} paths - paths to resolve\n* @param {Options} [options] - function options\n* @param {string} [options.dir] - base directory\n* @param {string} [options.mode='all'] - mode of operation\n* @throws {TypeError} first argument must be an array of strings\n* @throws {TypeError} options argument must be an object\n* @throws {TypeError} must provide valid options\n* @returns {Array<string|null>} resolved paths\n*\n* @example\n* var paths = resolveParentPaths( [ 'package.json', 'package-lock.json' ] );\n*/\nfunction resolveParentPaths( paths, options ) {\n\tvar opts;\n\tvar mode;\n\tvar dir;\n\tvar fcn;\n\tvar err;\n\n\tif ( !isStringArray( paths ) ) {\n\t\tif ( isArrayLikeObject( paths ) && paths.length === 0 ) {\n\t\t\treturn [];\n\t\t}\n\t\tthrow new TypeError( format( 'null3s', paths ) );\n\t}\n\topts = {};\n\tif ( arguments.length > 1 ) {\n\t\terr = validate( opts, options );\n\t\tif ( err ) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\tif ( opts.dir ) {\n\t\tdir = resolve( cwd(), opts.dir );\n\t} else {\n\t\tdir = cwd();\n\t}\n\tmode = opts.mode || 'all';\n\n\tfcn = MODES[ mode ];\n\treturn fcn( paths, dir );\n}\n\n\n// EXPORTS //\n\nexport default resolveParentPaths;\n","/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n/**\n* Resolve paths from a set of paths by walking parent directories.\n*\n* @module @stdlib/fs-resolve-parent-paths\n*\n* @example\n* import resolveParentPaths from '@stdlib/fs-resolve-parent-paths';\n*\n* resolveParentPaths( [ 'package.json', 'package-lock.json' ], onPaths );\n*\n* function onPaths( error, paths ) {\n*     if ( error ) {\n*         throw error;\n*     }\n*     console.log( paths );\n* }\n*\n* @example\n* import resolveParentPaths from '@stdlib/fs-resolve-parent-paths';\n*\n* var paths = resolveParentPaths.sync( [ 'package.json', 'package-lock.json' ] );\n*/\n\n// MODULES //\n\nimport setReadOnly from '@stdlib/utils-define-nonenumerable-read-only-property';\nimport main from './main.js';\nimport sync from './sync.js';\n\n\n// MAIN //\n\nsetReadOnly( main, 'sync', sync );\n\n\n// EXPORTS //\n\nexport default main;\n\n// exports: { \"sync\": \"main.sync\" }\n"],"names":["isMode","contains","validate","opts","options","isObject","hasOwnProp","dir","isString","TypeError","format","mode","resolve","require$$0","MODES","first","paths","done","child","spath","idx","out","exists","onExists","error","bool","push","length","some","FLG","next","i","getCallback","all","count","nulls","each","resolveParentPaths","clbk","err","isStringArray","isArrayLikeObject","arguments","isFunction","cwd","fcn","setReadOnly","main","sync"],"mappings":"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"}